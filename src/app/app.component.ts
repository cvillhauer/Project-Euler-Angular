import { Component } from '@angular/core';

import { Problem } from '../../src/app/problem';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  public problems: Problem[] = [];

  constructor(){

    //PROBLEM 1
    let problem1 = new Problem(1, "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.", 1000);
    problem1.solveProblem = function(): void { 
      let n: number = problem1.input;
      let i: number = 1;
      let result: number = 0;
      for(i = 1; i < n; i++){
        if(i % 3 == 0 || i % 5 == 0){
          result = result + i;
        }
      }
      this.result = result; 
    };

    problem1.notes += "Fairly straightforward! The most obvious 'brute force' solution is also probably the fastest. ";

    this.problems.push(problem1);


    //PROBLEM 2
    let problem2 = new Problem(2, "Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.", 4000000);
    problem2.solveProblem = function(): void { 
      let n: number = problem2.input;
      let i: number = 1;
      let j: number = 1;
      let k: number = 1;
      let result: number = 0;
      while(i <= n){
        if(i % 2 == 0){
          result = result + i;
        }
        k = i + j;
        j = i;
        i = k;
      }
      this.result = result;
    };

    problem2.notes += "The only sticky point here is the leap-frogging with i, j, and k. ";
    problem2.notes += "Handwriting out a diagram/flow chart of the logic helps me with stuff like this. ";

    this.problems.push(problem2);


    //PROBLEM 3
    let problem3 = new Problem(3, "The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?", 600851475143);
    problem3.solveProblem = function(): void { 
      let n: number = problem3.input;
      let i: number = 2;
      let j: number = n;
      let result: number = 0;
      for(i = 2; i <= j; i++)
      {
        if(j % i == 0)
        {
          //console.log(i); //Together, these "i" results will be the prime factorization of n
          if(i > result)
          {
            result = i;
          }
          j = j / i;
          i = 2;
        }
      }
      this.result = result;
    };
    
    problem3.notes += "On this one, I stumbled onto a solution that yielded the correct answer right away. However, it did not always produce a correct answer, if you varied n. ";
    problem3.notes += "I was cutting off the search for prime factors at the square root of n. 14 is a counter example - 7 is higher than the square root of 14 yet is its highest prime factor. ";
    problem3.notes += "However, brute forcing by finding every factor between 2-n, then identifying the highest prime one, would be much too slow. ";
    problem3.notes += "I needed to change the way I was thinking about this. Researching factorization on the internet helped me a lot. ";
    problem3.notes += "Instead of counting each factor, deciding if it was prime, and then storing it, I should instead step through a prime factorization. ";
    problem3.notes += "Find the smallest factor of n, and we know it is prime. Divide n by this prime and we have a new number to break down into primes (j). ";
    problem3.notes += "Repeat this process until your new number itself is prime. Probably the last number you land on is always the highest prime? ";
    problem3.notes += "There is probably room to increase efficiency here. Though it runs in less than 2 miliseconds, I'm going through the loop almost 10,000 times. ";
    problem3.notes += "I'm going to leave this as it is for now, but a future Euler problem will probably get me to reuse this, and that might require more speed! ";

    this.problems.push(problem3);


    //PROBLEM 4
    let problem4 = new Problem(4, "A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers.", 999);
    problem4.solveProblem = function(): void { 
      let n: number = problem4.input;
      let i: number = n;
      let j: number = n;
      let result: number = 0;
      while(i % 11 != 0){
        i = i-1; //First let's find the highest 3-digit number that is divisible by 11.
      }
      while(i > 0){
        for(j = n; j >= 1; j--){
          if(problem4.isPalindrome(i*j)){
            if(i*j > result){
              result = i*j;
            }
            break;
          }
        }
        i = i-11; //Step down by 11 to ensure next value is also divisible by 11.
      }
      this.result = result; 
    };

    problem4.notes += "I have no idea if there is a 'mathy' way to determine a number is a palindrome, but converting a number to a string and checking for palindrome seems like an obvious option. ";
    problem4.notes += "Shockingly, I got the right answer on my first try with a brute force attempt, even though I'm great at making off-by-one index errors. ";
    problem4.notes += "A performance of ~200 miliseconds isn't bad, but I'm sure we can do better. ";
    problem4.notes += "I wonder if it is faster to count down from n-1 rather than going from 1-n... This only works if we can break once we have the largest palindrome though. ";
    problem4.notes += "A lot of different methods I tried that were faster would get a lower (wrong) palindrome answer. ";
    problem4.notes += "A bit of internet research yielded the theoem that a palindrome number is divisible by 11, which means either i or j need to be divisible by 11. ";
    problem4.notes += "This made me decide to short-circuit my loops so that the outer loop steps down by 11 each time, which sped things up a lot. Down to 20 miliseconds ";
    problem4.notes += "I squeezed out a tiny bit more speed by breaking out of the inner loop once the first palindrome for that i value is found. Lowering j will only get us smaller palindromes. ";
    problem4.notes += "To maximize flexibility of my code, I'm not bothering to set the lower limits of i and j to 100 (smallest 3-digit number), I'm just leaving them at 1. ";

    this.problems.push(problem4);


    //PROBLEM 5
    let problem5 = new Problem(5, "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?", 20);
    problem5.solveProblem = function(): void { 
      let n: number = problem5.input;
      let i: number = 1;
      let j: number = n;
      let result: number = 1;
      let multiple: boolean = false;

      while(!multiple && j <= 3628800)
      {
        for(i = 1; i <= n; i++){
          if(j % i != 0){
            j = j+n;
            i = 1;
          }
          multiple = true;
          result = j;
        }
      }
      this.result = result; 
    };

    problem5.notes += "First thing I did was play around with numbers 1-10 compared to 2520. 10! is equal to 1440 * 2520, which feels interesting! ";
    problem5.notes += "Next of course I tried the most obvious brute-force solution to see what the timing looked like. ";
    problem5.notes += "I got the right answer, but it took over 4 seconds to get there. ";
    problem5.notes += "Since we know the final number must be divisible by n, we can increment j by n instead of 1, and that gets us down to 600 miliseconds.";
    problem5.notes += "This smells like a solution that could be sped up with usage of prime factorials... ";

    this.problems.push(problem5);


    //PROBLEM 6
    let problem6 = new Problem(6, "The sum of the squares of the first ten natural numbers is, 1^2 + 2^2 + ... + 10^2 = 385 The square of the sum of the first ten natural numbers is, (1 + 2 + ... + 10)^2 = 55^2 = 3025 Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.", 100);
    problem6.solveProblem = function(): void { 
      let n: number = problem6.input;
      let i: number = 1;
      let result: number = 0;
      let sumOfSquares: number = 0;
      let squareOfSums: number = 0;
      for(i = 1; i <= n; i++){
        sumOfSquares += i*i;
      }
      for(i = 1; i <= n; i++){
        squareOfSums += i;
      }
      squareOfSums = squareOfSums * squareOfSums;
      result = squareOfSums - sumOfSquares;
      this.result = result; 
    };

    problem6.notes += "This one was very straight-forward and the brute-force method takes a mere milisecond to yield the correct answer! ";

    this.problems.push(problem6);
    

    //PROBLEM 7
    let problem7 = new Problem(7, "By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 10 001st prime number?", 10001);
    problem7.solveProblem = function(): void { 
      let n: number = problem7.input;
      let currentNumber: number = 2; //We'll count 2 as a prime number by default
      let result: number = 0;
      
      for(let primeCount = 1; primeCount < n; currentNumber++)
      { 
        if(this.isPrime(currentNumber))
        {
          primeCount = primeCount + 1;
          result = currentNumber;
        }
      }
      this.result = result; 
    };

    problem7.notes += "This was actually my first Euler problem. First, I tried brute forcing by looping all the way through 2-n to see if a number n had any other factors. ";
    problem7.notes += "This worked, but took way too long, especially if you do it 10,000 times. Then I realized that any factor that might exist on the lower end has a cooresponding factor on the higher end. ";
    problem7.notes += "For example, if 1009 is not divisible by 2, it is also not divisible by ~500. So, I cut down my loop to 2-(n/2), which also worked and was much faster. ";
    problem7.notes += "After more research on prime numbers, I learned that the square root of a number is the true 'halfway point' for possible lower-half factors. ";
    problem7.notes += "For example, 49 is not a prime, but the only factor it has is 7, which is its square root. If we know there are no factors before 7, we know there are no factors after 7 because they would have to have a cooresponding lower factor.";

    this.problems.push(problem7);
  }
}
